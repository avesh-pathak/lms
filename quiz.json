{
  "topics": [
    {
      "name": "Prefix Sum",
      "questions": [
        {
          "id": 1,
          "question": "What is the primary purpose of a Prefix Sum array?",
          "options": [
            "To sort the array elements",
            "To calculate range sums in O(1) time after O(N) preprocessing",
            "To detect cycles in linked lists",
            "To merge overlapping intervals"
          ],
          "correct": 1,
          "explanation": "A Prefix Sum array pre-calculates cumulative sums, allowing subarray sum queries from L to R as Prefix[R] - Prefix[L-1] in constant time."
        },
        {
          "id": 2,
          "question": "Given an array [1, 2, 3, 4], what is the Prefix Sum array?",
          "options": [
            "[1, 3, 6, 10]",
            "[1, 2, 3, 4]",
            "[4, 3, 2, 1]",
            "[1, 1, 1, 1]"
          ],
          "correct": 0,
          "explanation": "Prefix[0] = 1, Prefix[1] = 1+2=3, Prefix[2]=3+3=6, Prefix[3]=6+4=10."
        },
        {
          "id": 3,
          "question": "What is the space complexity of a Prefix Sum approach?",
          "options": [
            "O(1)",
            "O(N)",
            "O(log N)",
            "O(N^2)"
          ],
          "correct": 1,
          "explanation": "The prefix array requires O(N) space to store cumulative sums."
        },
        {
          "id": 4,
          "question": "When should you use Prefix Sums? (Pattern Signal)",
          "options": [
            "For unsorted arrays only",
            "For multiple range sum queries on the same array",
            "For graph traversals",
            "For bit-level operations"
          ],
          "correct": 1,
          "explanation": "It is ideal for problems like 'Subarray sum equals K' or range queries to avoid repeated O(N) iterations."
        },
        {
          "id": 5,
          "question": "How do you compute the sum from index 2 to 4 in array [5,1,3,6,2] with prefix [5,6,9,15,17]?",
          "options": [
            "Prefix[4] - Prefix[1]",
            "Prefix[4] - Prefix[2]",
            "Prefix[2] + Prefix[4]",
            "Prefix[4] / Prefix[1]"
          ],
          "correct": 0,
          "explanation": "Sum = Prefix[4] - Prefix[1] = 17 - 6 = 11 (elements 3,6,2)."
        },
        {
          "id": 6,
          "question": "What if the array has negative numbers? Does Prefix Sum still work?",
          "options": [
            "Yes, the formula remains the same",
            "No, only positive numbers",
            "Requires absolute values",
            "Needs sorting first"
          ],
          "correct": 0,
          "explanation": "Prefix Sums handle negatives correctly as subtraction works regardless."
        },
        {
          "id": 7,
          "question": "In a 2D prefix sum, what does prefix[i][j] represent?",
          "options": [
            "Sum from (0,0) to (i,j)",
            "Sum of row i only",
            "Sum of column j only",
            "Diagonal sum"
          ],
          "correct": 0,
          "explanation": "Used for 2D range sums, e.g., sum from (x1,y1) to (x2,y2) via inclusion-exclusion."
        },
        {
          "id": 8,
          "question": "For 'Product of subarray', what is the equivalent?",
          "options": [
            "Prefix Product array, divide products",
            "Prefix Sum addition",
            "Log transform to sum",
            "Bitwise AND"
          ],
          "correct": 0,
          "explanation": "Similar to sums, but multiply cumulatively and divide for range."
        }
      ]
    },
    {
      "name": "Two Pointers",
      "questions": [
        {
          "id": 9,
          "question": "In the Two Pointers technique, what is the typical time complexity for a sorted array?",
          "options": [
            "O(N^2)",
            "O(N log N)",
            "O(N)",
            "O(log N)"
          ],
          "correct": 2,
          "explanation": "Two pointers traverse the array in a single pass, visiting each element at most once."
        },
        {
          "id": 10,
          "question": "Which variation of Two Pointers starts one at the beginning and one at the end?",
          "options": [
            "Same Direction",
            "Opposite Ends",
            "Fast and Slow",
            "Sliding Window"
          ],
          "correct": 1,
          "explanation": "Opposite Ends is used for pair-finding in sorted arrays, like Two Sum."
        },
        {
          "id": 11,
          "question": "What is a common application of Two Pointers?",
          "options": [
            "Reversing a string",
            "Cycle detection in graphs",
            "Heap operations",
            "Trie insertion"
          ],
          "correct": 0,
          "explanation": "It efficiently removes duplicates or reverses in-place without extra space."
        },
        {
          "id": 12,
          "question": "When is Two Pointers most effective? (Pattern Signal)",
          "options": [
            "On unsorted data",
            "When the array is sorted and finding pairs with a condition",
            "For dynamic programming subproblems",
            "For bit manipulation"
          ],
          "correct": 1,
          "explanation": "It shines in sorted arrays for problems like finding pairs summing to a target."
        },
        {
          "id": 13,
          "question": "For Three Sum, how do Two Pointers help after sorting?",
          "options": [
            "Fix one, use two for pair sum to -fixed",
            "Use three pointers directly",
            "No sorting needed",
            "Combine with heap"
          ],
          "correct": 0,
          "explanation": "Sort, fix i, left/right for j+k = -i, skip duplicates."
        },
        {
          "id": 14,
          "question": "In removing duplicates from sorted array, pointers move how?",
          "options": [
            "Slow for unique, fast to skip dups",
            "Both same speed",
            "Opposite always",
            "Random jumps"
          ],
          "correct": 0,
          "explanation": "Fast scans, slow places unique, overwrite."
        },
        {
          "id": 15,
          "question": "Space complexity?",
          "options": [
            "O(1)",
            "O(N)",
            "O(log N)",
            "O(N log N)"
          ],
          "correct": 0,
          "explanation": "In-place manipulation of indices."
        },
        {
          "id": 16,
          "question": "For container with most water, pointers start where?",
          "options": [
            "Ends, move smaller height inward",
            "Middle out",
            "Left to right sequentially",
            "No pointers"
          ],
          "correct": 0,
          "explanation": "Max area by height * width, greedy move shorter."
        }
      ]
    },
    {
      "name": "Dynamic Programming",
      "questions": [
        {
          "id": 17,
          "question": "What are the two main approaches in Dynamic Programming?",
          "options": [
            "Top-Down and Bottom-Up",
            "Recursive and Iterative",
            "Greedy and Backtracking",
            "BFS and DFS"
          ],
          "correct": 0,
          "explanation": "Memoization (Top-Down) and Tabulation (Bottom-Up) both avoid recomputing subproblems."
        },
        {
          "id": 18,
          "question": "In DP, what does overlapping subproblems mean?",
          "options": [
            "Subproblems that are independent",
            "Subproblems that are solved multiple times in naive recursion",
            "Subproblems with no optimal structure",
            "Subproblems requiring extra space"
          ],
          "correct": 1,
          "explanation": "DP stores results of overlapping subproblems to prevent redundant calculations."
        },
        {
          "id": 19,
          "question": "What is a classic DP problem?",
          "options": [
            "Fibonacci Sequence",
            "Binary Search",
            "Union Find",
            "Cyclic Sort"
          ],
          "correct": 0,
          "explanation": "Fibonacci uses dp[i] = dp[i-1] + dp[i-2] to compute efficiently."
        },
        {
          "id": 20,
          "question": "When to use DP? (Pattern Signal)",
          "options": [
            "For optimization or counting ways in problems with optimal substructure",
            "For linear traversals only",
            "For heap-based selections",
            "For interval merging"
          ],
          "correct": 0,
          "explanation": "Problems like 'Longest Common Subsequence' or 'House Robber' exhibit optimal substructure."
        },
        {
          "id": 21,
          "question": "Optimal substructure means?",
          "options": [
            "Optimal solution contains optimal subsolutions",
            "All subs independent",
            "No overlaps",
            "Greedy always works"
          ],
          "correct": 0,
          "explanation": "Core property for DP, e.g., knapsack."
        },
        {
          "id": 22,
          "question": "Space optimization in 1D DP like Fibonacci?",
          "options": [
            "Use two variables for prev/curr",
            "Full array always",
            "Recursion only",
            "Heap storage"
          ],
          "correct": 0,
          "explanation": "O(1) space by tracking last two."
        },
        {
          "id": 23,
          "question": "For 0/1 Knapsack, dp[i][w] = ?",
          "options": [
            "Max of include/exclude weight limit",
            "Sum of all",
            "Min cost",
            "Count ways"
          ],
          "correct": 0,
          "explanation": "dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])."
        },
        {
          "id": 24,
          "question": "LCS length recurrence?",
          "options": [
            "If match, 1 + LCS(i-1,j-1); else max(LCS(i-1,j), LCS(i,j-1))",
            "Always sum",
            "Min diff",
            "No match 0"
          ],
          "correct": 0,
          "explanation": "Builds alignment via diagonal or horizontal/vertical."
        }
      ]
    },
    {
      "name": "Math & Geometry",
      "questions": [
        {
          "id": 25,
          "question": "What is the Euclidean Algorithm used for?",
          "options": [
            "Sorting arrays",
            "Computing GCD",
            "Graph traversal",
            "Heap insertion"
          ],
          "correct": 1,
          "explanation": "gcd(a, b) = gcd(b, a % b) efficiently finds the Greatest Common Divisor."
        },
        {
          "id": 26,
          "question": "In geometry problems, how do you rotate a matrix 90 degrees clockwise?",
          "options": [
            "Transpose and reverse rows",
            "Reverse columns only",
            "Use BFS traversal",
            "Apply bit shifts"
          ],
          "correct": 0,
          "explanation": "Transpose (swap i,j with j,i) then reverse each row achieves 90-degree rotation."
        },
        {
          "id": 27,
          "question": "What is the Sieve of Eratosthenes for?",
          "options": [
            "Finding primes up to N",
            "Sorting numbers",
            "Detecting cycles",
            "Merging lists"
          ],
          "correct": 0,
          "explanation": "It marks multiples of each prime starting from 2 to identify all primes efficiently."
        },
        {
          "id": 28,
          "question": "Pattern Signal for Math & Geometry?",
          "options": [
            "Problems involving formulas like GCD or geometric overlaps without simulation",
            "Linked list reversals",
            "Dynamic subproblems",
            "Stack-based next greater"
          ],
          "correct": 0,
          "explanation": "Use for 'Count Primes' or 'Rotate Image' where math properties simplify solutions."
        },
        {
          "id": 29,
          "question": "To check if two line segments intersect?",
          "options": [
            "Use cross products for orientations",
            "Sum lengths",
            "GCD of endpoints",
            "Sieve on points"
          ],
          "correct": 0,
          "explanation": "Compute orientations; collinear and between bounds."
        },
        {
          "id": 30,
          "question": "Spiral matrix traversal order?",
          "options": [
            "Right, down, left, up; shrink bounds",
            "Row-major",
            "Diagonal",
            "Random"
          ],
          "correct": 0,
          "explanation": "Layer by layer, direction changes."
        },
        {
          "id": 31,
          "question": "For robot bounded in circle, check after 4 moves?",
          "options": [
            "Final pos (0,0) or dir not north",
            "Always bounded",
            "Count steps",
            "GCD turns"
          ],
          "correct": 0,
          "explanation": "If not back or facing north, will cycle."
        },
        {
          "id": 32,
          "question": "Happy number uses?",
          "options": [
            "Sum squares digits, cycle detect",
            "Prime check",
            "Geometry bounds",
            "Matrix rotate"
          ],
          "correct": 0,
          "explanation": "Math sum to 1 or loop."
        }
      ]
    },
    {
      "name": "HashMaps",
      "questions": [
        {
          "id": 33,
          "question": "What is the average time complexity for lookups in a HashMap?",
          "options": [
            "O(N)",
            "O(1)",
            "O(log N)",
            "O(N log N)"
          ],
          "correct": 1,
          "explanation": "HashMaps provide constant time average-case access via hashing keys."
        },
        {
          "id": 34,
          "question": "How does a HashMap optimize 'Two Sum'?",
          "options": [
            "By storing complements as keys",
            "By sorting the array",
            "By using two pointers",
            "By prefix sums"
          ],
          "correct": 0,
          "explanation": "Store num -> index; for each num, check if target - num exists."
        },
        {
          "id": 35,
          "question": "What is a Frequency Map in HashMaps?",
          "options": [
            "Key: Value, Value: Count",
            "Key: Index, Value: Sum",
            "Key: Node, Value: Pointer",
            "Key: Bit, Value: Mask"
          ],
          "correct": 0,
          "explanation": "It counts occurrences, e.g., for 'First non-repeating character'."
        },
        {
          "id": 36,
          "question": "When to use HashMaps? (Pattern Signal)",
          "options": [
            "For pair finding or grouping like anagrams",
            "For tree traversals",
            "For interval sorting",
            "For cyclic swaps"
          ],
          "correct": 0,
          "explanation": "Ideal for O(N) solutions to problems with duplicates or mappings."
        },
        {
          "id": 37,
          "question": "For anagrams grouping, sort string as key?",
          "options": [
            "Yes, sorted chars as key to group",
            "Use length only",
            "Prime product",
            "No hash"
          ],
          "correct": 0,
          "explanation": "Canonical form for equality."
        },
        {
          "id": 38,
          "question": "Handle collisions in HashMap?",
          "options": [
            "Chaining or open addressing",
            "Ignore",
            "Sort keys",
            "Use array"
          ],
          "correct": 0,
          "explanation": "Linked lists per bucket."
        },
        {
          "id": 39,
          "question": "LRU uses HashMap for?",
          "options": [
            "Key to node mapping",
            "Order only",
            "Eviction list",
            "Capacity count"
          ],
          "correct": 0,
          "explanation": "O(1) access to doubly linked list nodes."
        },
        {
          "id": 40,
          "question": "Subarray sum K, how many?",
          "options": [
            "Prefix sum - K in map count",
            "Total - K",
            "Linear scan",
            "Sort prefixes"
          ],
          "correct": 0,
          "explanation": "Map of prefix freq, add current - K lookups."
        }
      ]
    },
    {
      "name": "Tree Depth-First Search",
      "questions": [
        {
          "id": 41,
          "question": "What are the three orders in DFS for trees?",
          "options": [
            "Pre-Order, In-Order, Post-Order",
            "Level, Zigzag, Spiral",
            "BFS, DFS, Iterative",
            "Root, Leaf, Node"
          ],
          "correct": 0,
          "explanation": "Pre: Root-Left-Right; In: Left-Root-Right; Post: Left-Right-Root."
        },
        {
          "id": 42,
          "question": "In which order does In-Order traversal return sorted data for BST?",
          "options": [
            "Pre-Order",
            "In-Order",
            "Post-Order",
            "Level-Order"
          ],
          "correct": 1,
          "explanation": "Left subtree (smaller), root, right subtree (larger) yields sorted order."
        },
        {
          "id": 43,
          "question": "What is the space complexity of recursive DFS on trees?",
          "options": [
            "O(N)",
            "O(H) for recursion stack",
            "O(1)",
            "O(log N)"
          ],
          "correct": 1,
          "explanation": "Depends on tree height H, worst-case O(N) for skewed trees."
        },
        {
          "id": 44,
          "question": "Pattern Signal for Tree DFS?",
          "options": [
            "Path sums or validating BST structure",
            "Level-order printing",
            "Shortest path in unweighted graphs",
            "Heap min/max access"
          ],
          "correct": 0,
          "explanation": "Used for problems like 'Maximum Depth' or 'Path Sum' requiring deep exploration."
        },
        {
          "id": 45,
          "question": "Pre-order useful for?",
          "options": [
            "Copying tree structure",
            "Sorted output",
            "Delete order",
            "Level print"
          ],
          "correct": 0,
          "explanation": "Visit root first, then subtrees."
        },
        {
          "id": 46,
          "question": "Post-order for deletion why?",
          "options": [
            "Children before parent",
            "Parent first",
            "In-order sorted",
            "BFS levels"
          ],
          "correct": 0,
          "explanation": "Free children nodes before parent."
        },
        {
          "id": 47,
          "question": "Validate BST with DFS how?",
          "options": [
            "In-order check increasing, or bounds param",
            "Pre-order only",
            "Level check",
            "No DFS"
          ],
          "correct": 0,
          "explanation": "Recursive bounds: left < root < right."
        },
        {
          "id": 48,
          "question": "Path sum exists, return bool?",
          "options": [
            "DFS subtract till leaf ==0",
            "BFS queue sums",
            "Heap paths",
            "Sort nodes"
          ],
          "correct": 0,
          "explanation": "Recurse left/right with remaining sum."
        }
      ]
    },
    {
      "name": "Top K Elements",
      "questions": [
        {
          "id": 49,
          "question": "What data structure is typically used for Top K Elements?",
          "options": [
            "Min-Heap of size K",
            "Full sort",
            "Binary Search Tree",
            "Linked List"
          ],
          "correct": 0,
          "explanation": "Min-Heap maintains the K largest by replacing smallest when larger found."
        },
        {
          "id": 50,
          "question": "Time complexity for finding Kth largest using Heap?",
          "options": [
            "O(N log K)",
            "O(N log N)",
            "O(N^2)",
            "O(K)"
          ],
          "correct": 0,
          "explanation": "Build heap O(N), extract K times O(K log N), but optimized to O(N log K)."
        },
        {
          "id": 51,
          "question": "Example problem for Top K?",
          "options": [
            "K Closest Points to Origin",
            "Cycle Detection",
            "Interval Merge",
            "Trie Search"
          ],
          "correct": 0,
          "explanation": "Uses heap to track K nearest based on distance."
        },
        {
          "id": 52,
          "question": "When to use? (Pattern Signal)",
          "options": [
            "For large datasets needing only K extremes",
            "For full sorting always",
            "For graph connectivity",
            "For bit flips"
          ],
          "correct": 0,
          "explanation": "Efficient for 'Top K Frequent' without full sort."
        },
        {
          "id": 53,
          "question": "For frequent elements, use?",
          "options": [
            "Map to count, then max-heap by freq",
            "Sort array",
            "Linear scan",
            "No map"
          ],
          "correct": 0,
          "explanation": "Bucket sort by freq or heap."
        },
        {
          "id": 54,
          "question": "K closest, compare by?",
          "options": [
            "Euclidean distance squared",
            "Manhattan",
            "GCD",
            "Bit diff"
          ],
          "correct": 0,
          "explanation": "Heap on dist(point, origin)."
        },
        {
          "id": 55,
          "question": "Quickselect for Kth largest?",
          "options": [
            "Average O(N), worst O(N^2)",
            "Always O(N log N)",
            "O(log N)",
            "O(1)"
          ],
          "correct": 0,
          "explanation": "Partition like quicksort, recurse one side."
        },
        {
          "id": 56,
          "question": "In stream Kth largest, use?",
          "options": [
            "Min-heap size K, add if larger pop min",
            "Max-heap all",
            "Sort buffer",
            "Binary tree"
          ],
          "correct": 0,
          "explanation": "Maintains top K dynamically."
        }
      ]
    },
    {
      "name": "Matrices",
      "questions": [
        {
          "id": 57,
          "question": "How are matrices often treated in DSA?",
          "options": [
            "As graphs with adjacent cell connections",
            "As 1D arrays",
            "As heaps",
            "As tries"
          ],
          "correct": 0,
          "explanation": "Each cell is a node, edges to up/down/left/right neighbors."
        },
        {
          "id": 58,
          "question": "What traversal for shortest path in grid?",
          "options": [
            "BFS",
            "DFS",
            "Binary Search",
            "Greedy"
          ],
          "correct": 0,
          "explanation": "BFS explores level-by-level for unweighted shortest paths."
        },
        {
          "id": 59,
          "question": "Time complexity for visiting all cells in MxN matrix?",
          "options": [
            "O(M*N)",
            "O(M+N)",
            "O(log(M*N))",
            "O(1)"
          ],
          "correct": 0,
          "explanation": "Each cell visited once in traversal."
        },
        {
          "id": 60,
          "question": "Pattern Signal for Matrices?",
          "options": [
            "Island counting or word search in grids",
            "Prefix sums on 1D",
            "Heap for priorities",
            "Bitwise for integers"
          ],
          "correct": 0,
          "explanation": "For 'Number of Islands' using DFS/BFS on connected components."
        },
        {
          "id": 61,
          "question": "Directions array for 4-way grid?",
          "options": [
            "[[0,1],[1,0],[0,-1],[-1,0]]",
            "[[1,1],[1,-1],[-1,1],[-1,-1]]",
            "[[0,0]]",
            "Random"
          ],
          "correct": 0,
          "explanation": "Up, down, left, right deltas."
        },
        {
          "id": 62,
          "question": "For word search, mark visited how?",
          "options": [
            "Modify char to #, backtrack restore",
            "Separate set",
            "No mark",
            "Heap queue"
          ],
          "correct": 0,
          "explanation": "In-place for simplicity, undo on backtrack."
        },
        {
          "id": 63,
          "question": "Spiral order traversal?",
          "options": [
            "Boundaries shrink after layer",
            "Row by row",
            "Column wise",
            "Diagonal"
          ],
          "correct": 0,
          "explanation": "Right to left to up to down, repeat."
        },
        {
          "id": 64,
          "question": "Rotate matrix 90 clockwise in-place?",
          "options": [
            "Transpose then reverse rows",
            "Copy new array",
            "Reverse columns first",
            "No in-place"
          ],
          "correct": 0,
          "explanation": "Transpose swaps, reverse rows for 90 deg."
        }
      ]
    },
    {
      "name": "Sliding Window",
      "questions": [
        {
          "id": 65,
          "question": "What maintains the window in Sliding Window?",
          "options": [
            "Left and right pointers",
            "Stack",
            "Queue",
            "Heap"
          ],
          "correct": 0,
          "explanation": "Expand right, shrink left when invalid, update result."
        },
        {
          "id": 66,
          "question": "Time complexity of Sliding Window?",
          "options": [
            "O(N)",
            "O(N^2)",
            "O(N log N)",
            "O(2^N)"
          ],
          "correct": 0,
          "explanation": "Each element added/removed at most once."
        },
        {
          "id": 67,
          "question": "Example: Longest substring with unique chars?",
          "options": [
            "Dynamic window size",
            "Fixed size K",
            "Opposite pointers",
            "Cyclic sort"
          ],
          "correct": 0,
          "explanation": "Shrink when duplicate found, expand otherwise."
        },
        {
          "id": 68,
          "question": "When to use? (Pattern Signal)",
          "options": [
            "Contiguous subarrays/substrings with conditions",
            "Tree depths",
            "Graph cycles",
            "Bit counts"
          ],
          "correct": 0,
          "explanation": "For 'Max sum subarray of size K' or longest valid substring."
        },
        {
          "id": 69,
          "question": "Fixed size K max sum?",
          "options": [
            "Current sum += new - leaving",
            "Full recompute",
            "Sort window",
            "Heap maintain"
          ],
          "correct": 0,
          "explanation": "Maintain running sum, slide by subtracting arr[left]."
        },
        {
          "id": 70,
          "question": "For min window substring contain T?",
          "options": [
            "Count chars needed, shrink when valid",
            "Fixed length",
            "No counts",
            "Backtrack"
          ],
          "correct": 0,
          "explanation": "Use maps for required vs current, minimize valid."
        },
        {
          "id": 71,
          "question": "Longest no repeat, use?",
          "options": [
            "Last seen index map, left = max(left, last+1)",
            "Set only",
            "Sort chars",
            "Prefix"
          ],
          "correct": 0,
          "explanation": "Update left past last occurrence."
        },
        {
          "id": 72,
          "question": "Permutation in string, check full window?",
          "options": [
            "Char counts match T",
            "Length only",
            "Sum equal",
            "No check"
          ],
          "correct": 0,
          "explanation": "Freq maps equal for anagram window."
        }
      ]
    },
    {
      "name": "Backtracking",
      "questions": [
        {
          "id": 73,
          "question": "What is the core structure of Backtracking?",
          "options": [
            "Choose, Explore, Un-choose",
            "Sort, Search",
            "Push, Pop",
            "Union, Find"
          ],
          "correct": 0,
          "explanation": "Make choice, recurse, backtrack by undoing."
        },
        {
          "id": 74,
          "question": "Time complexity for permutations of N elements?",
          "options": [
            "O(N!)",
            "O(N log N)",
            "O(N)",
            "O(2^N)"
          ],
          "correct": 0,
          "explanation": "Exhaustively explores all possibilities."
        },
        {
          "id": 75,
          "question": "Classic problem?",
          "options": [
            "N-Queens",
            "Binary Search",
            "Heapify",
            "Prefix Sum"
          ],
          "correct": 0,
          "explanation": "Places queens row-by-row, backtracks on conflicts."
        },
        {
          "id": 76,
          "question": "Pattern Signal?",
          "options": [
            "Generating all combinations or solving puzzles like Sudoku",
            "Linear scans",
            "Level traversals",
            "Hash lookups"
          ],
          "correct": 0,
          "explanation": "For exhaustive search with pruning on invalid paths."
        },
        {
          "id": 77,
          "question": "Sudoku solver, check?",
          "options": [
            "Row, col, box no dup",
            "Only row",
            "Sum to 45",
            "No check"
          ],
          "correct": 0,
          "explanation": "Valid sets per unit before place."
        },
        {
          "id": 78,
          "question": "Combinations sum K, choose how?",
          "options": [
            "Start from last chosen or new",
            "All sequential",
            "Sort first",
            "Heap"
          ],
          "correct": 0,
          "explanation": "Avoid dups by increasing indices."
        },
        {
          "id": 79,
          "question": "Palindrome partitioning min cuts?",
          "options": [
            "DP check pal, backtrack cuts",
            "Always full",
            "No DP",
            "Greedy"
          ],
          "correct": 0,
          "explanation": "Precompute pal[i][j], recurse min partitions."
        },
        {
          "id": 80,
          "question": "Letter combinations phone, build?",
          "options": [
            "For each digit append mappings",
            "Sort letters",
            "Unique only",
            "No build"
          ],
          "correct": 0,
          "explanation": "Recursive add char options."
        }
      ]
    },
    {
      "name": "Binary Search",
      "questions": [
        {
          "id": 81,
          "question": "Prerequisite for Binary Search?",
          "options": [
            "Sorted data",
            "Unsorted array",
            "Graph representation",
            "Heap property"
          ],
          "correct": 0,
          "explanation": "Requires monotonic (sorted) input to halve search space."
        },
        {
          "id": 82,
          "question": "How to avoid integer overflow in mid calculation?",
          "options": [
            "low + (high - low)/2",
            " (low + high)/2",
            "low * high / 2",
            "low - high / 2"
          ],
          "correct": 0,
          "explanation": "Prevents overflow in large ranges."
        },
        {
          "id": 83,
          "question": "Time complexity?",
          "options": [
            "O(log N)",
            "O(N)",
            "O(N^2)",
            "O(1)"
          ],
          "correct": 0,
          "explanation": "Halves search space each step."
        },
        {
          "id": 84,
          "question": "Pattern Signal?",
          "options": [
            "Finding target or boundary in sorted array",
            "Subarray sums",
            "Tree levels",
            "Bit flips"
          ],
          "correct": 0,
          "explanation": "For 'Search in Rotated Sorted Array' or first bad version."
        },
        {
          "id": 85,
          "question": "Rotated sorted, find pivot?",
          "options": [
            "BS where nums[mid] > nums[mid+1]",
            "Linear scan",
            "No pivot",
            "Sort first"
          ],
          "correct": 0,
          "explanation": "Then BS in sorted half."
        },
        {
          "id": 86,
          "question": "Find peak in mountain array?",
          "options": [
            "BS mid, check slopes",
            "Ends always",
            "Sort",
            "Heap"
          ],
          "correct": 0,
          "explanation": "If left > mid go left, else right."
        },
        {
          "id": 87,
          "question": "First bad version, BS how?",
          "options": [
            "Low=1 high=n, mid bad? high=mid : low=mid+1",
            "Last good",
            "Linear",
            "Random"
          ],
          "correct": 0,
          "explanation": "Converge to first true."
        },
        {
          "id": 88,
          "question": "Sqrt(x) integer, BS range?",
          "options": [
            "1 to x, mid*mid <=x",
            "0 to x/2",
            "Full x",
            "No BS"
          ],
          "correct": 0,
          "explanation": "Find largest mid where mid^2 <=x."
        }
      ]
    },
    {
      "name": "Sort and Search",
      "questions": [
        {
          "id": 89,
          "question": "Average time for QuickSort?",
          "options": [
            "O(N log N)",
            "O(N^2)",
            "O(N)",
            "O(log N)"
          ],
          "correct": 0,
          "explanation": "Partition and recurse, average balanced pivots."
        },
        {
          "id": 90,
          "question": "Linear Search complexity?",
          "options": [
            "O(N)",
            "O(log N)",
            "O(1)",
            "O(N log N)"
          ],
          "correct": 0,
          "explanation": "Scans sequentially in worst case."
        },
        {
          "id": 91,
          "question": "Why sort before searching?",
          "options": [
            "Enables O(log N) binary search",
            "Reduces space",
            "Detects cycles",
            "Merges heaps"
          ],
          "correct": 0,
          "explanation": "Sorting transforms linear search to logarithmic."
        },
        {
          "id": 92,
          "question": "Pattern Signal?",
          "options": [
            "Arranging for efficient retrieval like kth smallest",
            "Dynamic memos",
            "Graph edges",
            "Interval overlaps"
          ],
          "correct": 0,
          "explanation": "For 'Merge sorted arrays' or finding order."
        },
        {
          "id": 93,
          "question": "Merge sort stable?",
          "options": [
            "Yes, preserves relative order",
            "No",
            "Sometimes",
            "Only if equal"
          ],
          "correct": 0,
          "explanation": "Merges without swapping equals."
        },
        {
          "id": 94,
          "question": "Heap sort uses?",
          "options": [
            "Build max-heap, extract root N times",
            "Quick partition",
            "Merge halves",
            "Insertion"
          ],
          "correct": 0,
          "explanation": "O(N log N) guaranteed."
        },
        {
          "id": 95,
          "question": "Kth smallest in unsorted, use?",
          "options": [
            "Quickselect average O(N)",
            "Full sort O(N log N)",
            "Linear O(N^2)",
            "Heap O(N log K)"
          ],
          "correct": 0,
          "explanation": "Partition to k position."
        },
        {
          "id": 96,
          "question": "Search in sorted rotated, adjust?",
          "options": [
            "Find pivot, BS in monotonic part",
            "Unrotate first",
            "Linear",
            "No search"
          ],
          "correct": 0,
          "explanation": "Treat as two sorted, compare to ends."
        }
      ]
    },
    {
      "name": "Trie",
      "questions": [
        {
          "id": 97,
          "question": "What does each node in a Trie represent?",
          "options": [
            "A character",
            "A full word",
            "A frequency count",
            "A pointer to root"
          ],
          "correct": 0,
          "explanation": "Paths from root spell words, nodes for chars."
        },
        {
          "id": 98,
          "question": "Time for inserting a word of length L?",
          "options": [
            "O(L)",
            "O(N)",
            "O(L * alphabet size)",
            "O(1)"
          ],
          "correct": 0,
          "explanation": "Traverses/creates L nodes."
        },
        {
          "id": 99,
          "question": "Use case?",
          "options": [
            "Autocomplete",
            "Cycle detection",
            "Heap min",
            "Prefix sum"
          ],
          "correct": 0,
          "explanation": "Efficient prefix-based searches."
        },
        {
          "id": 100,
          "question": "Pattern Signal?",
          "options": [
            "String storage/retrieval by prefixes like spell check",
            "Array traversals",
            "Tree BFS",
            "Bit masks"
          ],
          "correct": 0,
          "explanation": "For 'Longest Common Prefix' or word search."
        },
        {
          "id": 101,
          "question": "Search word, traverse till end flag?",
          "options": [
            "Yes, follow chars, check isEnd",
            "No flag",
            "Count nodes",
            "Heap words"
          ],
          "correct": 0,
          "explanation": "Boolean marks word end."
        },
        {
          "id": 102,
          "question": "Prefix exists, check path to depth L?",
          "options": [
            "All nodes present",
            "Only end",
            "No path",
            "Sort prefix"
          ],
          "correct": 0,
          "explanation": "For autocomplete, collect from subtree."
        },
        {
          "id": 103,
          "question": "Implement wordSearchII grid, how?",
          "options": [
            "BFS from each cell, trie check path",
            "Linear scan",
            "No trie",
            "Hash all"
          ],
          "correct": 0,
          "explanation": "Trie stores words, DFS grid with visited."
        },
        {
          "id": 104,
          "question": "Delete word, set end false, remove unused nodes?",
          "options": [
            "Yes, recurse remove if no children",
            "No delete",
            "Mark deleted",
            "Rebuild"
          ],
          "correct": 0,
          "explanation": "Clean up to save space."
        }
      ]
    },
    {
      "name": "Custom Data Structures",
      "questions": [
        {
          "id": 105,
          "question": "Example of Custom DS: LRU Cache uses?",
          "options": [
            "HashMap + Doubly Linked List",
            "Array + Heap",
            "Tree + Stack",
            "Graph + Queue"
          ],
          "correct": 0,
          "explanation": "Map for O(1) access, List for order eviction."
        },
        {
          "id": 106,
          "question": "Why combine structures?",
          "options": [
            "To meet specific O(1) ops",
            "To increase space",
            "To slow down",
            "To add cycles"
          ],
          "correct": 0,
          "explanation": "No single DS satisfies all constraints."
        },
        {
          "id": 107,
          "question": "Problem: Design Twitter uses?",
          "options": [
            "Heaps for feeds",
            "Custom for timelines",
            "Tries for users",
            "Matrices for posts"
          ],
          "correct": 1,
          "explanation": "Combines graphs for follows, heaps for recent posts."
        },
        {
          "id": 108,
          "question": "Pattern Signal?",
          "options": [
            "Design problems needing O(1) get/put like LRU",
            "Simple sorts",
            "Backtrack puzzles",
            "Union groups"
          ],
          "correct": 0,
          "explanation": "For 'Insert Delete GetRandom O(1)' combining sets/maps."
        },
        {
          "id": 109,
          "question": "TimeBasedKeyValueStore, use?",
          "options": [
            "Map<str, TreeMap<int, str>> for timestamps",
            "List append",
            "Hash only",
            "No tree"
          ],
          "correct": 0,
          "explanation": "SortedMap for range queries."
        },
        {
          "id": 110,
          "question": "SnakeGame, custom?",
          "options": [
            "Queue for body, set for positions",
            "Array fixed",
            "Heap scores",
            "Graph moves"
          ],
          "correct": 0,
          "explanation": "Dequeue tail, enqueue head, check collisions."
        },
        {
          "id": 111,
          "question": "MinStack, how O(1) min?",
          "options": [
            "Stack of pairs: val, curr_min",
            "Separate min stack",
            "Sort on pop",
            "No min"
          ],
          "correct": 0,
          "explanation": "Push min(val, top_min)."
        },
        {
          "id": 112,
          "question": "DesignHashMap, chaining?",
          "options": [
            "ListNode per bucket",
            "Array direct",
            "Tree balance",
            "No chain"
          ],
          "correct": 0,
          "explanation": "Handle collisions with linked lists."
        }
      ]
    },
    {
      "name": "Graphs",
      "questions": [
        {
          "id": 113,
          "question": "Representation: Adjacency List vs Matrix?",
          "options": [
            "List: Space-efficient for sparse",
            "Matrix: O(V^2) always",
            "Both same",
            "List for dense"
          ],
          "correct": 0,
          "explanation": "Lists use O(V+E), matrices O(V^2)."
        },
        {
          "id": 114,
          "question": "Traversal to avoid cycles?",
          "options": [
            "Visited set",
            "No need",
            "Only BFS",
            "Heap"
          ],
          "correct": 0,
          "explanation": "HashSet tracks processed nodes."
        },
        {
          "id": 115,
          "question": "Time complexity for traversal?",
          "options": [
            "O(V + E)",
            "O(V^2)",
            "O(E log V)",
            "O(1)"
          ],
          "correct": 0,
          "explanation": "Visits vertices and edges once."
        },
        {
          "id": 116,
          "question": "Pattern Signal?",
          "options": [
            "Path existence or connected components",
            "1D ranges",
            "Tree depths only",
            "Bit ops"
          ],
          "correct": 0,
          "explanation": "For 'Clone Graph' or 'Course Schedule'."
        },
        {
          "id": 117,
          "question": "Clone graph, DFS or BFS?",
          "options": [
            "DFS recurse copy neighbors",
            "BFS level",
            "No clone",
            "Sort nodes"
          ],
          "correct": 0,
          "explanation": "Map old to new nodes."
        },
        {
          "id": 118,
          "question": "Number of islands, treat as?",
          "options": [
            "1s connected 4-way",
            "All connected",
            "Diagonal too",
            "No graph"
          ],
          "correct": 0,
          "explanation": "DFS/BFS flood fill mark 0."
        },
        {
          "id": 119,
          "question": "Shortest path unweighted?",
          "options": [
            "BFS distances",
            "DFS depth",
            "Dijkstra",
            "No path"
          ],
          "correct": 0,
          "explanation": "Level gives dist."
        },
        {
          "id": 120,
          "question": "Pacific Atlantic Water Flow, from oceans?",
          "options": [
            "BFS from borders, reachable sets",
            "DFS all cells",
            "Sort heights",
            "Heap flow"
          ],
          "correct": 0,
          "explanation": "Union where >= prev."
        }
      ]
    },
    {
      "name": "Bitwise Manipulation",
      "questions": [
        {
          "id": 121,
          "question": "What does A ^ A equal?",
          "options": [
            "0",
            "1",
            "A",
            "2A"
          ],
          "correct": 0,
          "explanation": "XOR of number with itself cancels to 0."
        },
        {
          "id": 122,
          "question": "Check if number is odd?",
          "options": [
            "num & 1 == 1",
            "num | 1",
            "num ^ 1",
            "num << 1"
          ],
          "correct": 0,
          "explanation": "LSB is 1 for odds."
        },
        {
          "id": 123,
          "question": "Multiply by 2 using bits?",
          "options": [
            "<< 1",
            ">> 1",
            "& 1",
            "^ 0"
          ],
          "correct": 0,
          "explanation": "Left shift adds zero, multiplies by 2."
        },
        {
          "id": 124,
          "question": "Pattern Signal?",
          "options": [
            "Single non-duplicate or bit counts",
            "Array sums",
            "Graph unions",
            "Heap tops"
          ],
          "correct": 0,
          "explanation": "For 'Single Number' using XOR properties."
        },
        {
          "id": 125,
          "question": "Count set bits (popcount)?",
          "options": [
            "n & (n-1) loop till 0",
            "n & 1 sum",
            "n ^ 0",
            "n << 1"
          ],
          "correct": 0,
          "explanation": "Clears LSB each time."
        },
        {
          "id": 126,
          "question": "Single number II, all dup 3x?",
          "options": [
            "Bits mod 3 ==1",
            "XOR all",
            "Sum - 3*others",
            "No single"
          ],
          "correct": 0,
          "explanation": "Count bits %3."
        },
        {
          "id": 127,
          "question": "Reverse bits of 32-bit int?",
          "options": [
            "Bit by bit build, swap nibbles",
            "XOR reverse",
            "Shift left all",
            "No reverse"
          ],
          "correct": 0,
          "explanation": "For i=0 to 31, res |= (n>>i &1) << (31-i)."
        },
        {
          "id": 128,
          "question": "Missing number 0-N, XOR?",
          "options": [
            "XOR all nums ^ (0 to N)",
            "Sum - expected",
            "Sort find gap",
            "Hash"
          ],
          "correct": 0,
          "explanation": "XOR cancels dups, leaves missing."
        }
      ]
    },
    {
      "name": "Union Find",
      "questions": [
        {
          "id": 129,
          "question": "Core operations?",
          "options": [
            "Find root, Union sets",
            "Push pop",
            "Insert delete",
            "Sort search"
          ],
          "correct": 0,
          "explanation": "Find: get parent; Union: link roots."
        },
        {
          "id": 130,
          "question": "Optimization: Path Compression?",
          "options": [
            "Flattens tree to root",
            "Increases height",
            "Adds cycles",
            "Removes nodes"
          ],
          "correct": 0,
          "explanation": "Directs nodes to root for future O(1) finds."
        },
        {
          "id": 131,
          "question": "Time per op nearly?",
          "options": [
            "O(1) amortized",
            "O(N)",
            "O(log N)",
            "O(N^2)"
          ],
          "correct": 0,
          "explanation": "Inverse Ackermann, practically constant."
        },
        {
          "id": 132,
          "question": "Pattern Signal?",
          "options": [
            "Dynamic connectivity or MST",
            "String prefixes",
            "Window slides",
            "Backtrack choices"
          ],
          "correct": 0,
          "explanation": "For 'Redundant Connection' detecting cycles."
        },
        {
          "id": 133,
          "question": "Union by Rank, why?",
          "options": [
            "Attach smaller to larger, balance height",
            "Always first to second",
            "Random",
            "No rank"
          ],
          "correct": 0,
          "explanation": "Keeps trees shallow."
        },
        {
          "id": 134,
          "question": "Find with compression, set parent[i]=find(parent[i])?",
          "options": [
            "Recursive or iterative flatten",
            "No set",
            "Increase depth",
            "Delete node"
          ],
          "correct": 0,
          "explanation": "All along path point to root."
        },
        {
          "id": 135,
          "question": "Accounts Merge, use UF on emails?",
          "options": [
            "Union same name emails",
            "Separate graphs",
            "Sort only",
            "Heap"
          ],
          "correct": 0,
          "explanation": "Find root for group."
        },
        {
          "id": 136,
          "question": "Kruskal MST, sort edges, union if not same?",
          "options": [
            "Yes, add weight if connect components",
            "Dijkstra",
            "BFS",
            "No sort"
          ],
          "correct": 0,
          "explanation": "Greedy smallest non-cycle."
        }
      ]
    },
    {
      "name": "Stacks",
      "questions": [
        {
          "id": 137,
          "question": "Monotonic Stack purpose?",
          "options": [
            "Next greater element",
            "Sorting",
            "Graph edges",
            "Prefix calc"
          ],
          "correct": 0,
          "explanation": "Maintains increasing/decreasing order to pop smaller/larger."
        },
        {
          "id": 138,
          "question": "Time for Next Greater?",
          "options": [
            "O(N)",
            "O(N^2)",
            "O(N log N)",
            "O(1)"
          ],
          "correct": 0,
          "explanation": "Each pushed/popped once."
        },
        {
          "id": 139,
          "question": "Other use?",
          "options": [
            "Valid Parentheses",
            "Heap min",
            "Binary mid",
            "Union root"
          ],
          "correct": 0,
          "explanation": "Matching open/close tags."
        },
        {
          "id": 140,
          "question": "Pattern Signal?",
          "options": [
            "Next greater/smaller or histogram areas",
            "Tree levels",
            "Bit shifts",
            "Interval sorts"
          ],
          "correct": 0,
          "explanation": "For 'Daily Temperatures' or largest rectangle."
        },
        {
          "id": 141,
          "question": "Valid parens, push open, pop on close match?",
          "options": [
            "Yes, empty at end",
            "Count only",
            "No push",
            "Heap"
          ],
          "correct": 0,
          "explanation": "Top must match closing."
        },
        {
          "id": 142,
          "question": "Largest rectangle histogram, mono decreasing stack indices?",
          "options": [
            "Area = height * (right - left -1)",
            "Sort bars",
            "Prefix max",
            "No stack"
          ],
          "correct": 0,
          "explanation": "Pop when smaller, width to prev/next larger."
        },
        {
          "id": 143,
          "question": "Min stack, pair with min?",
          "options": [
            "Push val and curr_min",
            "Separate stack",
            "Sort on query",
            "No min"
          ],
          "correct": 0,
          "explanation": "Top pair's second is min."
        },
        {
          "id": 144,
          "question": "Asteroid collision, stack right-moving, pop if left collides larger?",
          "options": [
            "Yes, compare abs speeds",
            "All explode",
            "Sort asteroids",
            "Queue"
          ],
          "correct": 0,
          "explanation": "Simulate destructions."
        }
      ]
    },
    {
      "name": "Linked List: In-Place Manipulation",
      "questions": [
        {
          "id": 145,
          "question": "Pointers for reversal?",
          "options": [
            "Prev, Curr, Next",
            "Left, Right",
            "Slow, Fast",
            "Root, Leaf"
          ],
          "correct": 0,
          "explanation": "Next = Curr.next; Curr.next = Prev; advance."
        },
        {
          "id": 146,
          "question": "Space for in-place reverse?",
          "options": [
            "O(1)",
            "O(N)",
            "O(log N)",
            "O(N^2)"
          ],
          "correct": 0,
          "explanation": "Modifies pointers without extra list."
        },
        {
          "id": 147,
          "question": "Problem: Palindrome check?",
          "options": [
            "Reverse half and compare",
            "Sort nodes",
            "Use heap",
            "Prefix sums"
          ],
          "correct": 0,
          "explanation": "Find mid, reverse second half, match with first."
        },
        {
          "id": 148,
          "question": "Pattern Signal?",
          "options": [
            "Reversing lists or sublists",
            "Graph clones",
            "Dynamic tables",
            "Bit reverses"
          ],
          "correct": 0,
          "explanation": "For 'Reverse Nodes in k-Group'."
        },
        {
          "id": 149,
          "question": "Reverse k-group, count k, reverse segment?",
          "options": [
            "Yes, dummy head, reverse between prev end new",
            "Full reverse",
            "No count",
            "Heap"
          ],
          "correct": 0,
          "explanation": "Link prev to new head, tail to next."
        },
        {
          "id": 150,
          "question": "Merge two sorted lists, dummy?",
          "options": [
            "In-place compare, link smaller",
            "Sort combined",
            "Reverse one",
            "No dummy"
          ],
          "correct": 0,
          "explanation": "Dummy simplifies head."
        },
        {
          "id": 151,
          "question": "Remove nth from end, two pointers dist n?",
          "options": [
            "Fast ahead n, slow to remove prev",
            "Reverse find",
            "Count total",
            "Stack"
          ],
          "correct": 0,
          "explanation": "When fast end, slow at target."
        },
        {
          "id": 152,
          "question": "Add two numbers reversed, carry?",
          "options": [
            "Dummy, sum digits +carry, new node",
            "Convert to int",
            "Sort",
            "No add"
          ],
          "correct": 0,
          "explanation": "Dummy head, p=q traverse."
        }
      ]
    },
    {
      "name": "Greedy Programming",
      "questions": [
        {
          "id": 153,
          "question": "Key idea?",
          "options": [
            "Local optimum leads to global",
            "Exhaustive search",
            "Memoize all",
            "Backtrack all"
          ],
          "correct": 0,
          "explanation": "Choose best now, no regret later if matroid."
        },
        {
          "id": 154,
          "question": "Often requires?",
          "options": [
            "Sorting",
            "Dynamic table",
            "Heap only",
            "Union always"
          ],
          "correct": 0,
          "explanation": "Sort by end time for activity selection."
        },
        {
          "id": 155,
          "question": "Example?",
          "options": [
            "Jump Game",
            "Fibonacci",
            "BST Validate",
            "Trie Insert"
          ],
          "correct": 0,
          "explanation": "Max reach greedily."
        },
        {
          "id": 156,
          "question": "Pattern Signal?",
          "options": [
            "Local choices optimal like gas station",
            "Overlapping subs",
            "Cycle laps",
            "Prefix ranges"
          ],
          "correct": 0,
          "explanation": "For 'Activity Selection', but verify vs DP."
        },
        {
          "id": 157,
          "question": "Jump game II min jumps?",
          "options": [
            "Greedy max reach per level",
            "DP jumps[i]",
            "BFS exact",
            "Sort positions"
          ],
          "correct": 0,
          "explanation": "Current end, next end update max."
        },
        {
          "id": 158,
          "question": "Candy, min give based on ratings?",
          "options": [
            "Two pass: left to right, right to left max",
            "Equal all",
            "Sort kids",
            "No pass"
          ],
          "correct": 0,
          "explanation": "Ensure higher rating > neighbor."
        },
        {
          "id": 159,
          "question": "Gas station circuit, start where?",
          "options": [
            "Total gas >= cost, start min tank",
            "First always",
            "Sort stations",
            "No circuit"
          ],
          "correct": 0,
          "explanation": "One pass cumulative, reset on neg."
        },
        {
          "id": 160,
          "question": "Queue reconstruction height, greedy insert?",
          "options": [
            "Sort tall first, insert by k pos",
            "Short first",
            "No sort",
            "Heap"
          ],
          "correct": 0,
          "explanation": "People[k] taller in front."
        }
      ]
    },
    {
      "name": "Tree Breadth-First Search",
      "questions": [
        {
          "id": 161,
          "question": "Data structure for BFS?",
          "options": [
            "Queue",
            "Stack",
            "Heap",
            "Map"
          ],
          "correct": 0,
          "explanation": "FIFO for level order."
        },
        {
          "id": 162,
          "question": "For shortest path in tree?",
          "options": [
            "BFS",
            "DFS",
            "Binary Search",
            "Greedy"
          ],
          "correct": 0,
          "explanation": "Level-by-level finds minimal depth."
        },
        {
          "id": 163,
          "question": "Space complexity?",
          "options": [
            "O(W) width",
            "O(H) height",
            "O(1)",
            "O(N log N)"
          ],
          "correct": 0,
          "explanation": "Queue holds one level's nodes."
        },
        {
          "id": 164,
          "question": "Pattern Signal?",
          "options": [
            "Level order or min depth",
            "Deep paths",
            "Bit counts",
            "Window max"
          ],
          "correct": 0,
          "explanation": "For 'Zigzag Traversal' or connect siblings."
        },
        {
          "id": 165,
          "question": "Zigzag level order, alternate?",
          "options": [
            "Queue, reverse odd levels",
            "Stack two",
            "DFS",
            "No reverse"
          ],
          "correct": 0,
          "explanation": "Deque pop left/right alternate."
        },
        {
          "id": 166,
          "question": "Connect nodes same level, nextRight?",
          "options": [
            "Level queue, link consecutive",
            "Parent pointers",
            "In-order",
            "No connect"
          ],
          "correct": 0,
          "explanation": "While level, set next of prev to curr."
        },
        {
          "id": 167,
          "question": "Min depth to leaf?",
          "options": [
            "BFS till first leaf",
            "DFS max",
            "Height balanced",
            "Sort levels"
          ],
          "correct": 0,
          "explanation": "Shortest path to null child."
        },
        {
          "id": 168,
          "question": "Binary tree right side view?",
          "options": [
            "BFS last per level",
            "DFS right first",
            "Left view",
            "No view"
          ],
          "correct": 0,
          "explanation": "Queue, take back of level."
        }
      ]
    },
    {
      "name": "Intervals",
      "questions": [
        {
          "id": 169,
          "question": "Key step for merging?",
          "options": [
            "Sort by start",
            "Sort by end",
            "No sort",
            "Use heap"
          ],
          "correct": 0,
          "explanation": "Sort intervals by start time."
        },
        {
          "id": 170,
          "question": "Overlap condition?",
          "options": [
            "Curr.end >= Next.start",
            "Curr.start <= Next.end",
            "Curr.start == Next.start",
            "Curr.end == Next.start"
          ],
          "correct": 0,
          "explanation": "If true, merge with max end."
        },
        {
          "id": 171,
          "question": "Time complexity?",
          "options": [
            "O(N log N)",
            "O(N)",
            "O(N^2)",
            "O(1)"
          ],
          "correct": 0,
          "explanation": "Sort dominates."
        },
        {
          "id": 172,
          "question": "Pattern Signal?",
          "options": [
            "Merge overlaps or meeting rooms",
            "Tree nodes",
            "Hash frequencies",
            "Backtrack combos"
          ],
          "correct": 0,
          "explanation": "For 'Insert Interval' or CPU scheduling."
        },
        {
          "id": 173,
          "question": "Insert interval, merge with overlapping?",
          "options": [
            "Find overlap range, merge start min end max",
            "Append always",
            "Sort after",
            "No insert"
          ],
          "correct": 0,
          "explanation": "Binary search pos, but linear scan merge."
        },
        {
          "id": 174,
          "question": "Meeting rooms needed, sort ends?",
          "options": [
            "Sort starts/ends, scan count active",
            "Max overlap",
            "No sort",
            "Heap times"
          ],
          "correct": 0,
          "explanation": "Two pointers on sorted lists."
        },
        {
          "id": 175,
          "question": "Non-overlapping, sort end, pick earliest end?",
          "options": [
            "Greedy select non-overlap",
            "DP count",
            "BFS",
            "Hash"
          ],
          "correct": 0,
          "explanation": "Max intervals without overlap."
        },
        {
          "id": 176,
          "question": "Car pooling, capacity exceed?",
          "options": [
            "Sweep line: +pass -drop at times",
            "Simulate each",
            "Sort cars",
            "No check"
          ],
          "correct": 0,
          "explanation": "Sort events, track current."
        }
      ]
    },
    {
      "name": "Heaps",
      "questions": [
        {
          "id": 177,
          "question": "Heap property for Min-Heap?",
          "options": [
            "Parent <= Children",
            "Parent >= Children",
            "Sorted order",
            "Balanced only"
          ],
          "correct": 0,
          "explanation": "Root smallest."
        },
        {
          "id": 178,
          "question": "Insert complexity?",
          "options": [
            "O(log N)",
            "O(N)",
            "O(1)",
            "O(N log N)"
          ],
          "correct": 0,
          "explanation": "Bubble up to root."
        },
        {
          "id": 179,
          "question": "Use for median stream?",
          "options": [
            "Two heaps: max for lower, min for upper",
            "Single sort",
            "Binary tree",
            "Linked list"
          ],
          "correct": 0,
          "explanation": "Balances for O(log N) updates."
        },
        {
          "id": 180,
          "question": "Pattern Signal?",
          "options": [
            "Priority access like task scheduler",
            "String tries",
            "Graph topsort",
            "Cyclic swaps"
          ],
          "correct": 0,
          "explanation": "For 'Kth Largest in Stream'."
        },
        {
          "id": 181,
          "question": "Merge K lists, heap tuples (val, list_idx, node_idx)?",
          "options": [
            "Yes, pop min, add next from same list",
            "Concat all",
            "Sort each",
            "No merge"
          ],
          "correct": 0,
          "explanation": "O(N log K)."
        },
        {
          "id": 182,
          "question": "Task scheduler, max freq, idle (n-1)*(max-1) - less?",
          "options": [
            "Max(idles, tasks)",
            "Always tasks",
            "Sort all",
            "No idle"
          ],
          "correct": 0,
          "explanation": "Cool down n-1."
        },
        {
          "id": 183,
          "question": "Find median data stream, balance heaps sizes?",
          "options": [
            "Max left <= min right +1",
            "Equal always",
            "One heap",
            "Sort"
          ],
          "correct": 0,
          "explanation": "Median top left or avg tops."
        },
        {
          "id": 184,
          "question": "Reorganize string, heap (freq,char), greedy append if cool?",
          "options": [
            "Yes, track last used",
            "Sort string",
            "Hash count",
            "No reorganize"
          ],
          "correct": 0,
          "explanation": "No two same adjacent."
        }
      ]
    },
    {
      "name": "Segment Trees",
      "questions": [
        {
          "id": 185,
          "question": "Purpose over Prefix Sum?",
          "options": [
            "Handles updates in O(log N)",
            "No updates needed",
            "Faster queries only",
            "Less space"
          ],
          "correct": 0,
          "explanation": "Rebuilds affected segments on update."
        },
        {
          "id": 186,
          "question": "Root represents?",
          "options": [
            "Full range [0,N]",
            "Single leaf",
            "Half only",
            "Empty"
          ],
          "correct": 0,
          "explanation": "Children halves, leaves elements."
        },
        {
          "id": 187,
          "question": "Query/Update time?",
          "options": [
            "O(log N)",
            "O(N)",
            "O(1)",
            "O(N log N)"
          ],
          "correct": 0,
          "explanation": "Log levels to leaf."
        },
        {
          "id": 188,
          "question": "Pattern Signal?",
          "options": [
            "Mutable range queries like RMQ",
            "Static sums",
            "Heap merges",
            "Bit singles"
          ],
          "correct": 0,
          "explanation": "For 'Range Sum with Updates'."
        },
        {
          "id": 189,
          "question": "Build tree, 4*N size array?",
          "options": [
            "Yes, recursive halve ranges",
            "N size",
            "Dynamic nodes",
            "No build"
          ],
          "correct": 0,
          "explanation": "Indices 1 root, 2-3 children."
        },
        {
          "id": 190,
          "question": "Range min query, combine min children?",
          "options": [
            "Yes, tree[node] = min(left,right)",
            "Sum",
            "Max",
            "No combine"
          ],
          "correct": 0,
          "explanation": "For RMQ."
        },
        {
          "id": 191,
          "question": "Lazy propagation for range update?",
          "options": [
            "Propagate pending on query/update descend",
            "No lazy",
            "Update leaves only",
            "Rebuild"
          ],
          "correct": 0,
          "explanation": "Defer updates to subtrees."
        },
        {
          "id": 192,
          "question": "Count range sum >k, how?",
          "options": [
            "Merge sort tree or fenwick",
            "Simple query",
            "No count",
            "Heap"
          ],
          "correct": 0,
          "explanation": "Advanced, but segment can store sorted or count."
        }
      ]
    },
    {
      "name": "Fast and Slow Pointers",
      "questions": [
        {
          "id": 193,
          "question": "Speeds for cycle detection?",
          "options": [
            "Slow:1, Fast:2",
            "Both 1",
            "Slow:2, Fast:1",
            "Random"
          ],
          "correct": 0,
          "explanation": "Fast laps slow in loop."
        },
        {
          "id": 194,
          "question": "For list middle?",
          "options": [
            "When fast ends, slow at mid",
            "Slow ends first",
            "Both meet end",
            "No use"
          ],
          "correct": 0,
          "explanation": "Half speed reaches mid."
        },
        {
          "id": 195,
          "question": "Space complexity?",
          "options": [
            "O(1)",
            "O(N)",
            "O(log N)",
            "O(N^2)"
          ],
          "correct": 0,
          "explanation": "In-place pointers."
        },
        {
          "id": 196,
          "question": "Pattern Signal?",
          "options": [
            "Cycle detection or happy numbers",
            "Array pairs",
            "Tree orders",
            "Graph unions"
          ],
          "correct": 0,
          "explanation": "For 'Linked List Cycle' start."
        },
        {
          "id": 197,
          "question": "Cycle start, after meet, reset slow to head, move both 1?",
          "options": [
            "Yes, meet dist to cycle start",
            "No reset",
            "Fast only",
            "Count length"
          ],
          "correct": 0,
          "explanation": "Math: entry = meet point."
        },
        {
          "id": 198,
          "question": "Happy number, sum sq digits till 1 or cycle?",
          "options": [
            "Slow/fast on num transform",
            "Prime check",
            "Sort digits",
            "No cycle"
          ],
          "correct": 0,
          "explanation": "Floyd on sequence."
        },
        {
          "id": 199,
          "question": "Remove duplicates II, keep two same?",
          "options": [
            "Dummy, skip if three consec",
            "Set unique",
            "Reverse",
            "Heap"
          ],
          "correct": 0,
          "explanation": "Count streak."
        },
        {
          "id": 200,
          "question": "Partition list around x, two lists < >=?",
          "options": [
            "Dummy less/greater, concat",
            "Sort all",
            "No partition",
            "Stack"
          ],
          "correct": 0,
          "explanation": "In-place link."
        }
      ]
    },
    {
      "name": "Topological Sort",
      "questions": [
        {
          "id": 201,
          "question": "Requires?",
          "options": [
            "DAG no cycles",
            "Any graph",
            "Trees only",
            "Heaps"
          ],
          "correct": 0,
          "explanation": "Directed Acyclic Graph."
        },
        {
          "id": 202,
          "question": "Kahn's uses?",
          "options": [
            "In-degrees and queue",
            "Stack DFS",
            "Heap priorities",
            "Map keys"
          ],
          "correct": 0,
          "explanation": "Process zero in-degree, reduce neighbors."
        },
        {
          "id": 203,
          "question": "Time?",
          "options": [
            "O(V+E)",
            "O(V^2)",
            "O(E log V)",
            "O(1)"
          ],
          "correct": 0,
          "explanation": "Traverses all vertices/edges."
        },
        {
          "id": 204,
          "question": "Pattern Signal?",
          "options": [
            "Scheduling with prereqs like courses",
            "Cycle finds",
            "Window expands",
            "Bit XORs"
          ],
          "correct": 0,
          "explanation": "For 'Alien Dictionary' order."
        },
        {
          "id": 205,
          "question": "DFS topo, post-order reverse?",
          "options": [
            "Yes, add on finish recurse",
            "Pre-order",
            "Level",
            "No DFS"
          ],
          "correct": 0,
          "explanation": "Finish times reverse."
        },
        {
          "id": 206,
          "question": "Course schedule possible if topo size == numCourses?",
          "options": [
            "Yes, no cycle",
            "Always",
            "If 0 indeg",
            "No check"
          ],
          "correct": 0,
          "explanation": "Kahn's if all processed."
        },
        {
          "id": 207,
          "question": "Alien dict, graph chars from words?",
          "options": [
            "Adj from consec diff, topo",
            "Sort words",
            "No graph",
            "Heap chars"
          ],
          "correct": 0,
          "explanation": "Unique order."
        },
        {
          "id": 208,
          "question": "Sequence reconstruction, only if topo unique?",
          "options": [
            "Yes, one possible order",
            "Any topo",
            "Cycle check only",
            "No unique"
          ],
          "correct": 0,
          "explanation": "All topo same."
        }
      ]
    },
    {
      "name": "K-way merge",
      "questions": [
        {
          "id": 209,
          "question": "Uses for merging K lists?",
          "options": [
            "Min-Heap of heads",
            "Full sort each",
            "Binary search",
            "Stack push"
          ],
          "correct": 0,
          "explanation": "Heap pops smallest, adds next from list."
        },
        {
          "id": 210,
          "question": "Time complexity?",
          "options": [
            "O(N log K)",
            "O(N log N)",
            "O(K N)",
            "O(1)"
          ],
          "correct": 0,
          "explanation": "N elements, log K heap ops."
        },
        {
          "id": 211,
          "question": "Space?",
          "options": [
            "O(K)",
            "O(N)",
            "O(1)",
            "O(N K)"
          ],
          "correct": 0,
          "explanation": "Heap holds K elements."
        },
        {
          "id": 212,
          "question": "Pattern Signal?",
          "options": [
            "Merge K sorted or K pairs smallest sums",
            "Single list sort",
            "Tree BFS",
            "Custom cache"
          ],
          "correct": 0,
          "explanation": "For 'Merge K Sorted Lists'."
        },
        {
          "id": 213,
          "question": "K smallest pairs, heap (sum, i, j)?",
          "options": [
            "Yes, expand smaller sum next",
            "Sort all pairs",
            "No K",
            "Binary"
          ],
          "correct": 0,
          "explanation": "Prune large sums."
        },
        {
          "id": 214,
          "question": "Smallest range covering K lists elements?",
          "options": [
            "Heap one from each, min max diff, advance min",
            "Merge all",
            "Sort each",
            "No range"
          ],
          "correct": 0,
          "explanation": "Track current pointers."
        },
        {
          "id": 215,
          "question": "Ugly number II, dp min heap multiples 2,3,5?",
          "options": [
            "Yes, avoid dups pop used",
            "Factor all",
            "Prime sieve",
            "No heap"
          ],
          "correct": 0,
          "explanation": "nth 2*3*5 power."
        },
        {
          "id": 216,
          "question": "Super ugly, multiples of k primes?",
          "options": [
            "Heap or dp with pointers per prime",
            "Single heap",
            "Sort",
            "No super"
          ],
          "correct": 0,
          "explanation": "Generalize ugly."
        }
      ]
    },
    {
      "name": "Subsets",
      "questions": [
        {
          "id": 217,
          "question": "Approach: Cascading BFS?",
          "options": [
            "Copy existing, add new element",
            "Backtrack only",
            "Sort first",
            "Heap top"
          ],
          "correct": 0,
          "explanation": "For each elem, duplicate subsets and append."
        },
        {
          "id": 218,
          "question": "Number of subsets for N unique?",
          "options": [
            "2^N",
            "N!",
            "N^2",
            "1"
          ],
          "correct": 0,
          "explanation": "Include/exclude each element."
        },
        {
          "id": 219,
          "question": "Handle duplicates?",
          "options": [
            "Sort and skip same",
            "Ignore",
            "Use set",
            "Heap"
          ],
          "correct": 0,
          "explanation": "Sort input, skip identical in backtrack."
        },
        {
          "id": 220,
          "question": "Pattern Signal?",
          "options": [
            "Power set or permutations generation",
            "Graph paths",
            "Interval merges",
            "Bit singles"
          ],
          "correct": 0,
          "explanation": "For 'Subsets II' with dups."
        },
        {
          "id": 221,
          "question": "Bit mask for subsets, for i in 0 to (1<<n)-1?",
          "options": [
            "Yes, bits set elements include",
            "No mask",
            "Sort mask",
            "Heap"
          ],
          "correct": 0,
          "explanation": "O(2^n * n) build."
        },
        {
          "id": 222,
          "question": "Permutations, swap indices backtrack?",
          "options": [
            "Yes, for i in start to n, swap i, recurse, swap back",
            "No swap",
            "Sort perm",
            "Queue"
          ],
          "correct": 0,
          "explanation": "Generate all orders."
        },
        {
          "id": 223,
          "question": "Combinations, choose k from n, increasing indices?",
          "options": [
            "Start from prev+1, recurse k-1",
            "Any order",
            "Dups ok",
            "No choose"
          ],
          "correct": 0,
          "explanation": "Avoid order dups."
        },
        {
          "id": 224,
          "question": "Word break, subsets of dict words?",
          "options": [
            "DP possible, backtrack paths",
            "Always break",
            "No dp",
            "Sort words"
          ],
          "correct": 0,
          "explanation": "Recurse if prefix in dict."
        }
      ]
    },
    {
      "name": "Cyclic Sort",
      "questions": [
        {
          "id": 225,
          "question": "Assumes array range?",
          "options": [
            "1 to N",
            "Any unsorted",
            "Sorted already",
            "Duplicates only"
          ],
          "correct": 0,
          "explanation": "Numbers from 1 to N for index matching."
        },
        {
          "id": 226,
          "question": "Swap logic?",
          "options": [
            "To correct index nums[i]-1",
            "To end",
            "Random",
            "No swap"
          ],
          "correct": 0,
          "explanation": "While not in place, swap with target pos."
        },
        {
          "id": 227,
          "question": "Time?",
          "options": [
            "O(N)",
            "O(N log N)",
            "O(N^2)",
            "O(1)"
          ],
          "correct": 0,
          "explanation": "Each swapped at most once."
        },
        {
          "id": 228,
          "question": "Pattern Signal?",
          "options": [
            "Find missing/duplicate in 1-N range",
            "Tree sorts",
            "Hash groups",
            "Greedy jumps"
          ],
          "correct": 0,
          "explanation": "For 'Find Duplicate Number'."
        },
        {
          "id": 229,
          "question": "Find duplicate, swap to index, while !=i and in range?",
          "options": [
            "Yes, cycle will point to dup",
            "Sort all",
            "Hash seen",
            "No find"
          ],
          "correct": 0,
          "explanation": "Floyd on indices."
        },
        {
          "id": 230,
          "question": "Missing number, after sort, find i != nums[i]?",
          "options": [
            "Yes, or XOR all",
            "Sum - expected",
            "Always 0",
            "No missing"
          ],
          "correct": 0,
          "explanation": "Linear after O(N)."
        },
        {
          "id": 231,
          "question": "Duplicates in array 1-N with one dup, find?",
          "options": [
            "Swap, count swaps to dup index",
            "Linear",
            "Sort",
            "Heap"
          ],
          "correct": 0,
          "explanation": "Dup causes extra swaps."
        },
        {
          "id": 232,
          "question": "First missing positive, ignore non-pos, cyclic 1 to len+1?",
          "options": [
            "Yes, find first not in pos",
            "All pos",
            "Neg only",
            "No first"
          ],
          "correct": 0,
          "explanation": "Treat as 1 to n+1 perm."
        }
      ]
    }
  ]
}